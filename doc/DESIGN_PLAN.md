1. Introduction

Our motivation behind creating this program is to create a simulation of cellular automata that is flexible and easy to use on the user's end. This flexibility will be because of the abstract classes that we are planning to create which will allow for easy creation of new simulation classes.  These abstract classes will serve as the foundation of the architecture for this program, with subclasses representing simulations and cells.  A main method will setup the user interface and run a particular simulation based on user input, and allow users to return and choose a different one, as well as alter the parameters of the simulation. The classes will be open for extension and use but closed for modification.  Unrelated to design, one other main goal for our team is to gain experience working in a team environment and benefit from working together on a program, an experience some of us have yet to have.

2. Overview

As mentioned above, the abstract classes enable maximum flexibility with the program.  We are creating a Simulation abstract class which each individual simulation is a subclass of.  Each simulation has its own methods depending on the rules of the game, details to be discussed more in depth in the design details below. These simulation subclasses will include the GameOfLifeSimulation, SegregationSimulation, PredatorPreySimulation, FireSimulation, and PercolationSimulation.  The parent class will contain general methods such as updateCellState and createGrid to update our data and the user display as we step through the program, and a getMyDisplayFile method to get the XML files.  We also have an abstract class called Cell that serves as the skeleton for each of the different cell types that we are going to be working with within each specific simulation.  Each individual simulation will then have cell subclasses that represent the different types of cells particular to that specific simulation (won't repeat each one again here).  For example, water cells, fire cells, and tree cells, whatever cells are particular to each particular game.  These Cell subclasses will have individual updateImage and updateCell methods.  We also have a UserInterface class that creates and shows the display through createDisplay and showDisplay.  How everything works together will be elaborated further in the Design Details. A picture representation is included in the docs folder as well, both the original UML and a picture of the layout as well.(docs/cellUML.PNG) and (docs/UML.mdj)



3. User Interface

The program will consist of a single display screen with the right side containing buttons to switch between different simulations, and the left side containing the current simulation being run.  The initial state of the screen will contain a starting image in the simulation window when no simulation is being run yet. The bottom of the screen will have buttons enabling users to toggle speed, step through the simulation, and pause/play it as well.  We've attached a file in the doc folder that is a visual representation of the UI. (docs/ui_plan)

4. Design Details

The main class is the RunCellSociety class, which will read the XML file, create the simulation, create the display, and also be in charge of stepping through the simulation as time passes, as well as checking for if a button is pressed.  This method works with the UserInterface class, which creates and displays a UI that the user interacts with.  The UI will be in charge of creating the buttons for choosing between simulations, as well as the buttons for adjusting the simulation speed, pausing the simulation, and stepping through it as well. A new Simulation object will be created in the RunCellSociety class, and this is where the grid is created and the cell states updated.  We will be using a 2D array of Cell Objects.  The Cell class is abstract, and the subclasses will contain objects with specific ImageViews and states to that class.  

As for how the simulation will pass through time, the rules will all be contained in the specific Simulation subclass that is currently running. Thinking through potential use cases, for a grid of size n, for any cell that is not in the first or last rows, we will simply count all the neighbors left, right, up, and down and then store the state as usual.  However, with an edge case, whichever side is the edge will simply not be considered (determined using if statements) to avoid an Exception.  Running this logic through a for loop will enable all states to be updated with updateState, from which updateImage can be run for each cell and display the new Image in the grid. If it's necessary to set parameters for simulations, the XML parser can assign the value to a variable and then pass this variable into whichever Simulation subclass is being utilized.  Since we are planning for everything to be on a single screen, the buttons to switch between simulations will still be accessible even when the simulation is running.

Our design emphasis is on flexibility.  Having a main simulation class with each subclass containing its own rules make it very simple to add additional Simulation types by simplying extending this abstract Simulation class.  Likewise, abstracting the main Cell class enables great flexibility with creating different cells unique to each particular simulation. Our main class will never have to change much, and the organization into various classes affords a degree of simplicity even with so many different simulations and cells.  For example, further separation of the UserInterface class makes the code even clearer from a reviewer's perspective and makes it easier to alter the display buttons and toggles without altering the main class much.


5. Design Considerations

One design decision was where to put the step method, either running it in the main or putting it as part of the abstract simulation class.  Originally we considered placing it within the abstract simulation since the step method can technically be thought of as part of the simulation class, which organizationally made more sense originally.  However, after analzying our code samples from the Breakout game and thinking through the nature of the method, we thought it would serve best in the main RunCellSociety method, as it is part of the overall running process. The step is used in general for the game and not unique per simulation, and we believed it would make more sense in both organization and implementation to show this method in the main class.

We are operating under the assumption that the shapes of the grid spaces will be squares, creating a 2D array of Cell objects.  If there is any other unique grid shape, our current approach would have to be altered to take into account the various configurations of shapes and think of data structures that take the varying number of neighbors into account.

We are also operating under the assumption that simulation parameters are always run through the XML and we never take user input for the parameters and initial states. Given that we are asked to use user input as parameters, our plan for configuration would have to change.



6. Team Responsibilities

For this initial Sprint, Brian will take the load on the visualization aspect, since he's comfortable working with and likes JavaFX.  Bryant will work on the configuration aspect with the XML file, and Feroze will take lead on the simulation aspect.  Bryant and Feroze will work closely on the simulation together for the time being, and Bryant and Brian will work closely to figure out how values parsed from the XML will be translated into paramters for displays on the front-end.  As these initial steps are taken, we will shift responsibility as tasks are completed and devote effort depending on which areas are lacking.  Once the configuration is created, we will create a grid and begin to implement rules for the first simulation.  Along with this, we will also be working on the front-end and test that both our grid data and visuals are updating concurrently.  We'll then implement the various features such as toggling speed, pausing and playing the simulation, and the option to step through it.  Once this initial framework is tested and seems successful, we will work together to incrementally add more simulation types.  With the exiting skeleton in place, these remaining steps should just be extensions of the abstract classes already created.  Once the back-end is tested and works, we can then work on polishing the front-end and then seeing if any extra features should be added.
