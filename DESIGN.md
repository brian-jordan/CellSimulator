- High level design goals
    - Our biggest focus was modularity and making sure that given the complexity of the project requirements, we would be able to make changes quickly and without problems.  Our methods were written flexibily and split up into specific functionality so that methods could easily be changed.  Each package had to deal with a specific part of the program, and the classes in the packages all served functions specific to the package.  We had a great focus on encapsulation, making sure that each class only contained methods particular to objects of that class.  We also focused on the communication between classes, making sure that information passed between classes was concentrated and that there wouldn't be dependencies in too many different methods.  Interaction between the cell level and grid was limited to a few access points, and likewise with the grid and the visualization aspect.  
- How to add new features in detail
    - Simulation
        - We used Java reflection so adding more simulation types is easier. After packaging the cell rules of the new simulation within a class placed in `CellPackage`, one just has to create a suitable XML document for the simulation and make sure that its title tag matches the class name (making sure that the class name is `<SimulationName>Cell`). After that, the `CellManager` class will populate the grid with the appropriate type of cell automatically.
    - Configuration
        - Our grid was designed to isolate all features of a cell such that a cell has no knowledge of everything outside of its local environment (neighbors). Because of this, several new features can be added easily; for one, if a user wanted to pass other objects into the grid, apart from cells, one could achieve this by altering the `CellSpace` class to hold another object instead of a cell. The grid only maintains references to these `CellSpaces`, so theoretically, any object could be mounted within a CellSpace. In order to add more parameters to the Simulation, it would require adding in tags to the XML and then adding that tag to the list of features that make up either the `gameConfig` or `cellConfig` maps. 
    - Visualization
        - Adding new features to the front-end of the program involves making changes to the RunPackage and Resources package.  Specifically any changes to the Program at the highest level are made in the RunCellSociety class including the initial speed of simulations, how erorr methods are presented and what is displayed when a simulation is being created.  The UserInterface class would be changed if the general layout of the screen wanted to be changed or aspects wanted to be added or removed.  The FileBar and StatePlot classes would be changed to update the visualization of these specific parts of the UI or their characteristics of file selection and plotting respectively.  Any changes to the styling of the program can be made in the default.css file of the Resources package.  This includes the styling of individual node boxes, buttons, and Text fields.  The Strings.properties file of the Resources package contains the strings displayed in the User Interface and easily be modified to edit a title box, button name, or information text.
- Major design choices, including trade-offs (i.e., pros and cons), made in your project
    - One design choice we made very early was to package everything about the Simulation so that the front-end could treat it as a `Group` and place it within the main window wherever it saw fit. In that way, adding and removing fully functional simulations was very easy. In addition, the front-end had a layer of abstraction between what it had to manage and what was going on within the society; front-end simply had to call `Simulation.update()` and the Simulation could do its own thing. Another major design decision we made was to allow for either a stat graph or an extra simulation to be displayed, but not both. We figured that that choice would be best to display functionality and not clutter the screen, but in retrospect we could have possibly added a separate window pop up to display everything.
    - Another design choice was that we had the rules within the cell subclasses and made each subclasses very specific to the simulation.  We decided to have a single simulation class and have the distinctions within the cell subclasses.  The abstract cell class contains multiple methods that all subclasses use, and some are overriden for particular cases.  We thought that having rules in the Cell subclasses made the most sense since we are making changes to the cell states.
- Any assumptions or decisions made to simplify or resolve ambiguities in the project's functionality
    - One technical assumption we make is in the form of generics, mainly when dealing with lists of cells. In order to make the lists open to all cell types, we assume that the lists will be populated by subclasses of `Cell` by specifying a container `List<? extends Cell>`. The wildcard ensures that the list is full of cells but of any cell type. We assume in some areas that 1) these objects are cells, or the code won't compile and 2) these cells are all of the same type and have the same methods.
    - Another assumption we made was that when iterating through a grid, we would treat those cells iterated thorugh or changed as 'isChanged', and would not consider these cells for additional state changes or alteration.  This simplified the rules instead of looking at the grid from a high level standpoint and trying to maximize the movements.  It simplified writing the rules but served a similar level of functionality.
    - For the front-end of the program, a simplification in the project's functionality involved only having one set of control buttons that adjusted the operation of simulations even when two simulations were depicted simultaneously.  One reason for this is to be consistent with the purpose of running duel simulations as to compare the change of cell states over time.  The other reason was to simplify the code to not have to map a specific running simulation to a specific control pannel and monitor both sets of controlls.
